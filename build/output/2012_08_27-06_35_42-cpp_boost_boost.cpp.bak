// ************************************************************
// @parser_description
// 		Early Version of Parser Generator
// @parser_authors
// 		Michael Jedich
// @parser_version
// 		0.8
// ************************************************************
// @dsl_description
// 		Sample file with two testfunctions
// @dsl_authors
// 		Michael Jedich
// @dsl_version
// 		0.8, 23.03.2012
// ************************************************************

#include <stdio.h>
#include <cstdlib>
#include <string>

#define BOOST_NUMERIC_INTERVAL_HPP
#include <boost/limits.hpp>
#include <boost/numeric/interval/interval.hpp>
#include <boost/numeric/interval/policies.hpp>
#include <boost/numeric/interval/hw_rounding.hpp>
#include <boost/numeric/interval/rounded_arith.hpp>
#include <boost/numeric/interval/rounded_transc.hpp>
#include <boost/numeric/interval/constants.hpp>
#include <boost/numeric/interval/checking.hpp>
#include <boost/numeric/interval/compare.hpp>
#include <boost/numeric/interval/utility.hpp>
#include <boost/numeric/interval/arith.hpp>
#include <boost/numeric/interval/arith2.hpp>
#include <boost/numeric/interval/arith3.hpp>
#include <boost/numeric/interval/transc.hpp>
using namespace boost;
using namespace numeric;
using namespace interval_lib;
using namespace std;
typedef policies<save_state<rounded_transc_exact<double> >, checking_base<double> > P;

#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_MODULE "main_unit_test"
#include <boost/test/unit_test.hpp>


float hexStringToFloat(std::string hexStr) {
	unsigned length = sizeof(float);
	unsigned char temp[length];
	std::string searchString("0x");
	std::string::size_type pos = 0;
	while ((pos = hexStr.find(searchString, pos)) != std::string::npos) {
		hexStr.replace(pos, searchString.size(), "");
		pos++; 
	}
	for (unsigned i = 0; i < hexStr.size(); i += 2)
		temp[i / 2] = strtol(hexStr.substr(i, 2).c_str(), 0, 16);
	unsigned char hex_array[length];
	for (unsigned i = 0; i < length; i++) {
		hex_array[length - 1 - i] = temp[i];
	}
	float x;
	std::copy(hex_array, hex_array + length, reinterpret_cast<char*> (&x));
	return x;
}

double hexStringToDouble(std::string hexStr) {
	unsigned double_length = sizeof(double);
	unsigned char temp[double_length];
	std::string searchString("0x");
	std::string::size_type pos = 0;
	while ((pos = hexStr.find(searchString, pos)) != std::string::npos) {
		hexStr.replace(pos, searchString.size(), "");
		pos++;
	}
	for (unsigned i = 0; i < hexStr.size(); i += 2)
		temp[i / 2] = strtol(hexStr.substr(i, 2).c_str(), 0, 16);
	unsigned char hex_array[double_length];
	for (unsigned i = 0; i < double_length; i++) {
		hex_array[double_length - 1 - i] = temp[i];
	}
	double x;
	std::copy(hex_array, hex_array + double_length,
	reinterpret_cast<char*> (&x));
	return x;
}

BOOST_AUTO_TEST_SUITE(testSuite);

// @name
// 		subtraction
// @description
// 		Simple subtraction test: 
// 		[-2 , 15] - [2.12, 4.5112] = [-6.5112, 12.88]
// @optional
// 		false
BOOST_AUTO_TEST_CASE(testcase_01_subtraction)
{
	// input parameter 1:
	float input_01_lower = hexStringToFloat("0xC0000000");
	float input_01_upper = hexStringToFloat("0x41700000");
	interval<float, P> input_01(input_01_lower, input_01_upper);
	// input parameter 2:
	float input_02_lower = hexStringToFloat("0x4007AE14");
	float input_02_upper = hexStringToFloat("0x40905BC0");
	interval<float, P> input_02(input_02_lower, input_02_upper);
	// expected output parameter 1:
	float output_01_lower = hexStringToFloat("0xC0D05BC0");
	float output_01_upper = hexStringToFloat("0x414E147B");
	interval<float, P> output_01(output_01_lower, output_01_upper);
	
	// operation to test: subtraction
	interval<float, P> lib_output_01 = input_01 - input_02;
	
	// assert function for output 1:
	float lo_output_01 = output_01.lower();
	float lo_lib_output_01 = lib_output_01.lower();
	BOOST_REQUIRE_EQUAL(lo_output_01, lo_lib_output_01);
	float hi_output_01 = output_01.upper();
	float hi_lib_output_01 = lib_output_01.upper();
	BOOST_REQUIRE_EQUAL(hi_output_01, hi_lib_output_01);
	
}

// @name
// 		median
// @optional
// 		false
BOOST_AUTO_TEST_CASE(testcase_02_median)
{
	// input parameter 1:
	double input_01_lower = hexStringToDouble("0x4000000000000000");
	double input_01_upper = hexStringToDouble("0x4028000000000000");
	interval<double, P> input_01(input_01_lower, input_01_upper);
	// expected output parameter 1:
	int output_01 = 7;
	
	// operation to test: median
	int lib_output_01 = median(input_01);
	
	// assert function for output 1:
	BOOST_REQUIRE_EQUAL(output_01, lib_output_01);
	
}

BOOST_AUTO_TEST_SUITE_END();
