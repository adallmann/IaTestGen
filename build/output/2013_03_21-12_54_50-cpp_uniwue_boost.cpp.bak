// ************************************************************
// @parser_description
// 		Early Version of Parser Generator
// @parser_authors
// 		Michael Jedich
// @parser_version
// 		0.8
// ************************************************************
// @dsl_description
// 		Sample-file with a couple of simple testfunctions
// @dsl_authors
// 		Michael Jedich
// @dsl_version
// 		0.8, 23.03.2012
// ************************************************************

#include <stdio.h>
#include <cstdlib>
#include <string>

#include "p1788/p1788.hpp"template<typename T>using interval = p1788::infsup::interval<T, p1788::flavor::infsup::ieee754_flavor>;

#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_MODULE "main_unit_test"
#include <boost/test/unit_test.hpp>


float hexStringToFloat(std::string hexStr) {
	unsigned length = sizeof(float);
	unsigned char temp[length];
	std::string searchString("0x");
	std::string::size_type pos = 0;
	while ((pos = hexStr.find(searchString, pos)) != std::string::npos) {
		hexStr.replace(pos, searchString.size(), "");
		pos++; 
	}
	for (unsigned i = 0; i < hexStr.size(); i += 2)
		temp[i / 2] = strtol(hexStr.substr(i, 2).c_str(), 0, 16);
	unsigned char hex_array[length];
	for (unsigned i = 0; i < length; i++) {
		hex_array[length - 1 - i] = temp[i];
	}
	float x;
	std::copy(hex_array, hex_array + length, reinterpret_cast<char*> (&x));
	return x;
}

double hexStringToDouble(std::string hexStr) {
	unsigned double_length = sizeof(double);
	unsigned char temp[double_length];
	std::string searchString("0x");
	std::string::size_type pos = 0;
	while ((pos = hexStr.find(searchString, pos)) != std::string::npos) {
		hexStr.replace(pos, searchString.size(), "");
		pos++;
	}
	for (unsigned i = 0; i < hexStr.size(); i += 2)
		temp[i / 2] = strtol(hexStr.substr(i, 2).c_str(), 0, 16);
	unsigned char hex_array[double_length];
	for (unsigned i = 0; i < double_length; i++) {
		hex_array[double_length - 1 - i] = temp[i];
	}
	double x;
	std::copy(hex_array, hex_array + double_length,
	reinterpret_cast<char*> (&x));
	return x;
}

BOOST_AUTO_TEST_SUITE(testSuite);

// @name
// 		addition
// @description
// 		Simple substraction test
// @optional
// 		false
BOOST_AUTO_TEST_CASE(testcase_01_addition)
{
	// input parameter 1:
	float input_01_lower = hexStringToFloat("0x41200000");
	float input_01_upper = hexStringToFloat("0x41700000");
	interval<float> input_01(input_01_lower, input_01_upper);
	// input parameter 2:
	float input_02_lower = hexStringToFloat("0x3F800000");
	float input_02_upper = hexStringToFloat("0x40000000");
	interval<float> input_02(input_02_lower, input_02_upper);
	// expected output parameter 1:
	double output_01_lower = hexStringToDouble("0x4020000000000000");
	double output_01_upper = hexStringToDouble("0x402C000000000000");
	interval<double> output_01(output_01_lower, output_01_upper);
	
	// operation to test: addition
	interval<double> lib_output_01 = p1788::infsup::add<interval<double>>(input_01, input_02);
	
	// assert function for output 1:
	double lo_output_01 = output_01.lower();
	double lo_lib_output_01 = lib_output_01.lower();
	BOOST_REQUIRE_EQUAL(lo_output_01, lo_lib_output_01);
	double hi_output_01 = output_01.upper();
	double hi_lib_output_01 = lib_output_01.upper();
	BOOST_REQUIRE_EQUAL(hi_output_01, hi_lib_output_01);
	
}

BOOST_AUTO_TEST_SUITE_END();
