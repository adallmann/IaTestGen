/* Generated By:JavaCC: Do not edit this line. DSLParser.java */
package de.uniwue.info2.parser;
import de.uniwue.info2.numerics.FloatingPoint;
import de.uniwue.info2.numerics.prec.DoublePrecisionFloat;
import de.uniwue.info2.numerics.prec.SinglePrecisionFloat;
import de.uniwue.info2.operations.GenericParameter;
import de.uniwue.info2.operations.Set;
import de.uniwue.info2.operations.Interval;
import de.uniwue.info2.operations.Operation;
import de.uniwue.info2.generator.OperationsPool;
import de.uniwue.info2.operations.Endpoints;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.HashMap;


/**
 * Parser for the Domain Specific Language.
 * 
 * @author Michael Jedich
 */

@SuppressWarnings("unused")
public class DSLParser implements DSLParserConstants {
  // dsl information, updated by the dsl
  private static String dslAuthors, dslVersion, dslDescription;

  // information for generated parser
  // if parser has been modified, update this information:
  private final static String parserDescription =
                "Early Version of Parser Generator";
  private final static String parserVersion = "0.8";
  private final static String parserAuthors = "Copyright 2013\u005cnMarco Nehmeier"
                        + " (nehmeier@informatik.uni-wuerzburg.de)\u005cn"
                        + "Institute of Computer Science,\u005cnUniversity of Wuerzburg, Germany"
                        + "\u005cn\u005cnMichael Jedich (m.jedich@gmail.com)\u005cn"
                        + "University of Wuerzburg, Germany";
  // variables specified in the dsl
  private HashMap<String, GenericParameter<?>> variables_;

  // operations specified in the dsl
  private OperationsPool operations_;

  // current operation found in the dsl
  private Operation currentOperation_;
  private String currentOperationDescription_ = null;
  private boolean currentOperationRequired_ = true;
  private boolean currentOperationInputMode_ = true;
        private Class<?> currentMixedTypeOutput_ = null;

  // used for an exception message when handling variables
  private String lastUsedVariableName_;
  private int lastUsedVariableLineNumber_;
  private int lastUsedVariableColumnNumber_;

  /**
   * DSL-Parser constructor.
   * 
   * @param dslFile
   *            given Domain Specific Language - File
   * @throws FileNotFoundException
   */
  public DSLParser(File dslFile) throws FileNotFoundException
  {
    this (new FileReader(dslFile));
    this.operations_ = new OperationsPool();
    variables_ = new HashMap<String, GenericParameter<?>>();
  }

  /**
   * Get authors specified in the Domain Specific Language.
   * 
   * @return DSL authors in single String
   */
  public String getDslAuthors()
  {
    return dslAuthors;
  }

  /**
   * Get version of Domain Specific Language.
   * 
   * @return DSL version as String
   */
  public String getDslVersion()
  {
    return dslVersion;
  }

  /**
   * Get description of Domain Specific Language.
   * 
   * @return DSL description
   */
  public String getDslDescription()
  {
    return dslDescription;
  }

  /**
   * Get description of current parser.
   * 
   * @return Parser description
   */
  public static String getParserDescription()
  {
    return parserDescription;
  }

  /**
   * Get version of current parser.
   * 
   * @return Parser version
   */
  public static String getParserVersion()
  {
    return parserVersion;
  }

  /**
   * Get authors of current parser.
   * 
   * @return Parser authors in single String.
   */
  public static String getParserAuthors()
  {
    return parserAuthors;
  }

/* --------------------------------------------------------- */
/* ------------------GRAMMER-SPECIFICATION------------------ */
/* --------------------------------------------------------- */

// main grammer
  final public OperationsPool parse() throws ParseException {
    dslHeaderBlockComment();
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BEGIN_BLOCK_COMMENT:
      case VARIABLE_NAME:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 65:
      case 66:
      case 67:
      case 68:
      case 69:
      case 70:
      case 71:
      case 72:
      case 73:
      case 74:
      case 75:
      case 76:
      case 77:
      case 78:
      case 79:
      case 80:
      case 81:
      case 82:
      case 83:
      case 84:
      case 85:
      case 86:
      case 87:
      case 88:
      case 89:
      case 90:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 97:
      case 98:
      case 99:
      case 100:
      case 101:
      case 102:
      case 103:
      case 104:
      case 105:
      case 106:
      case 107:
      case 108:
      case 109:
      case 110:
      case 111:
      case 112:
      case 113:
      case 114:
      case 115:
      case 116:
      case 117:
      case 118:
      case 119:
      case 120:
      case 121:
      case 122:
      case 123:
      case 124:
      case 125:
      case 126:
      case 127:
      case 128:
      case 129:
      case 130:
      case 131:
      case 132:
      case 133:
      case 134:
      case 135:
      case 136:
      case 137:
      case 138:
      case 139:
      case 140:
      case 141:
      case 142:
      case 143:
      case 144:
      case 145:
      case 146:
      case 147:
      case 148:
      case 149:
      case 150:
      case 151:
      case 152:
      case 153:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BEGIN_BLOCK_COMMENT:
        operationBlockComment();
        break;
      case VARIABLE_NAME:
        variable();
        break;
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 65:
      case 66:
      case 67:
      case 68:
      case 69:
      case 70:
      case 71:
      case 72:
      case 73:
      case 74:
      case 75:
      case 76:
      case 77:
      case 78:
      case 79:
      case 80:
      case 81:
      case 82:
      case 83:
      case 84:
      case 85:
      case 86:
      case 87:
      case 88:
      case 89:
      case 90:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 97:
      case 98:
      case 99:
      case 100:
      case 101:
      case 102:
      case 103:
      case 104:
      case 105:
      case 106:
      case 107:
      case 108:
      case 109:
      case 110:
      case 111:
      case 112:
      case 113:
      case 114:
      case 115:
      case 116:
      case 117:
      case 118:
      case 119:
      case 120:
      case 121:
      case 122:
      case 123:
      case 124:
      case 125:
      case 126:
      case 127:
      case 128:
      case 129:
      case 130:
      case 131:
      case 132:
      case 133:
      case 134:
      case 135:
      case 136:
      case 137:
      case 138:
      case 139:
      case 140:
      case 141:
      case 142:
      case 143:
      case 144:
      case 145:
      case 146:
      case 147:
      case 148:
      case 149:
      case 150:
      case 151:
      case 152:
      case 153:
        operation();
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(0);
                // return extracted operations of given Domain-Specific-Language
                {if (true) return operations_;}
    throw new Error("Missing return statement in function");
  }

/* ----------------Define operations here:------------------ */
  final public void operation() throws ParseException {
  Token operation;
  this.currentOperation_ = new Operation();
  this.currentOperation_.setDescription(this.currentOperationDescription_);
  this.currentOperation_.setRequired(this.currentOperationRequired_);
  this.currentOperationInputMode_ = true;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 53:
      // posibile parameters
      // interval(),  bool(), number()
      
      // -----------------------------------------------------------------------------
      /// Non-arithmetic set operations, see P1788/D7.1 Sect. 9.6.7
      // -----------------------------------------------------------------------------
              operation = jj_consume_token(53);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      interval();
      break;
    case 54:
      operation = jj_consume_token(54);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      interval();
      break;
    case 55:
      // -----------------------------------------------------------------------------
      // Numeric functions on intervals, see P1788/D7.1 Sect. 9.6.9
      // -----------------------------------------------------------------------------
              operation = jj_consume_token(55);
      input();
      interval();
      output();
      number();
      break;
    case 56:
      operation = jj_consume_token(56);
      input();
      interval();
      output();
      number();
      break;
    case 57:
      operation = jj_consume_token(57);
      input();
      interval();
      output();
      number();
      break;
    case 58:
      operation = jj_consume_token(58);
      input();
      interval();
      output();
      number();
      break;
    case 59:
      operation = jj_consume_token(59);
      input();
      interval();
      output();
      number();
      jj_consume_token(SP);
      number();
      break;
    case 60:
      operation = jj_consume_token(60);
      input();
      interval();
      output();
      number();
      break;
    case 61:
      operation = jj_consume_token(61);
      input();
      interval();
      output();
      number();
      break;
    case 62:
      operation = jj_consume_token(62);
      input();
      interval();
      output();
      number();
      break;
    case 63:
      // -----------------------------------------------------------------------------
      // Boolean functions on intervals, see P1788/D7.0 Sect. 9.6.10
      // -----------------------------------------------------------------------------
              operation = jj_consume_token(63);
      input();
      interval();
      output();
      bool();
      break;
    case 64:
      operation = jj_consume_token(64);
      input();
      interval();
      output();
      bool();
      break;
    case 65:
      operation = jj_consume_token(65);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      bool();
      break;
    case 66:
      operation = jj_consume_token(66);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      bool();
      break;
    case 67:
      operation = jj_consume_token(67);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      bool();
      break;
    case 68:
      operation = jj_consume_token(68);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      bool();
      break;
    case 69:
      operation = jj_consume_token(69);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      bool();
      break;
    case 70:
      operation = jj_consume_token(70);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      bool();
      break;
    case 71:
      operation = jj_consume_token(71);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      bool();
      break;
    case 72:
      operation = jj_consume_token(72);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      bool();
      break;
    case 73:
      operation = jj_consume_token(73);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      bool();
      break;
    case 74:
      operation = jj_consume_token(74);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      bool();
      break;
    case 75:
      operation = jj_consume_token(75);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      bool();
      break;
    case 76:
      operation = jj_consume_token(76);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      bool();
      break;
    case 77:
      operation = jj_consume_token(77);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      bool();
      break;
    case 78:
      operation = jj_consume_token(78);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      bool();
      break;
    case 79:
      // -----------------------------------------------------------------------------
      // Forward elementary functions
      // -----------------------------------------------------------------------------
              operation = jj_consume_token(79);
      input();
      interval();
      output();
      interval();
      break;
    case 80:
      operation = jj_consume_token(80);
      input();
      interval();
      output();
      interval();
      break;
    case 81:
      operation = jj_consume_token(81);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      interval();
      break;
    case 82:
      operation = jj_consume_token(82);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      interval();
      break;
    case 83:
      operation = jj_consume_token(83);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      interval();
      break;
    case 84:
      operation = jj_consume_token(84);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      interval();
      break;
    case 85:
      operation = jj_consume_token(85);
      input();
      interval();
      output();
      interval();
      break;
    case 86:
      operation = jj_consume_token(86);
      input();
      interval();
      output();
      interval();
      break;
    case 87:
      operation = jj_consume_token(87);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      jj_consume_token(SP);
      interval();
      output();
      interval();
      break;
    case 88:
      operation = jj_consume_token(88);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      jj_consume_token(SP);
      interval();
      output();
      interval();
      break;
    case 89:
      operation = jj_consume_token(89);
      input();
      interval();
      output();
      interval();
      break;
    case 90:
      operation = jj_consume_token(90);
      input();
      interval();
      jj_consume_token(SP);
      number();
      output();
      interval();
      break;
    case 91:
      operation = jj_consume_token(91);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      interval();
      break;
    case 92:
      operation = jj_consume_token(92);
      input();
      interval();
      output();
      interval();
      break;
    case 93:
      operation = jj_consume_token(93);
      input();
      interval();
      output();
      interval();
      break;
    case 94:
      operation = jj_consume_token(94);
      input();
      interval();
      output();
      interval();
      break;
    case 95:
      operation = jj_consume_token(95);
      input();
      interval();
      output();
      interval();
      break;
    case 96:
      operation = jj_consume_token(96);
      input();
      interval();
      output();
      interval();
      break;
    case 97:
      operation = jj_consume_token(97);
      input();
      interval();
      output();
      interval();
      break;
    case 98:
      operation = jj_consume_token(98);
      input();
      interval();
      output();
      interval();
      break;
    case 99:
      operation = jj_consume_token(99);
      input();
      interval();
      output();
      interval();
      break;
    case 100:
      operation = jj_consume_token(100);
      input();
      interval();
      output();
      interval();
      break;
    case 101:
      operation = jj_consume_token(101);
      input();
      interval();
      output();
      interval();
      break;
    case 102:
      operation = jj_consume_token(102);
      input();
      interval();
      output();
      interval();
      break;
    case 103:
      operation = jj_consume_token(103);
      input();
      interval();
      output();
      interval();
      break;
    case 104:
      operation = jj_consume_token(104);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      interval();
      break;
    case 105:
      operation = jj_consume_token(105);
      input();
      interval();
      output();
      interval();
      break;
    case 106:
      operation = jj_consume_token(106);
      input();
      interval();
      output();
      interval();
      break;
    case 107:
      operation = jj_consume_token(107);
      input();
      interval();
      output();
      interval();
      break;
    case 108:
      operation = jj_consume_token(108);
      input();
      interval();
      output();
      interval();
      break;
    case 109:
      operation = jj_consume_token(109);
      input();
      interval();
      output();
      interval();
      break;
    case 110:
      operation = jj_consume_token(110);
      input();
      interval();
      output();
      interval();
      break;
    case 111:
      operation = jj_consume_token(111);
      input();
      interval();
      output();
      interval();
      break;
    case 112:
      operation = jj_consume_token(112);
      input();
      interval();
      output();
      interval();
      break;
    case 113:
      operation = jj_consume_token(113);
      input();
      interval();
      output();
      interval();
      break;
    case 114:
      operation = jj_consume_token(114);
      input();
      interval();
      output();
      interval();
      break;
    case 115:
      operation = jj_consume_token(115);
      input();
      interval();
      output();
      interval();
      break;
    case 116:
      operation = jj_consume_token(116);
      input();
      interval();
      output();
      interval();
      break;
    case 117:
      operation = jj_consume_token(117);
      input();
      interval();
      output();
      interval();
      break;
    case 118:
      operation = jj_consume_token(118);
      input();
      interval();
      label_2:
      while (true) {
        jj_consume_token(SP);
        interval();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SP:
          ;
          break;
        default:
          jj_la1[2] = jj_gen;
          break label_2;
        }
      }
      output();
      interval();
      break;
    case 119:
      operation = jj_consume_token(119);
      input();
      interval();
      label_3:
      while (true) {
        jj_consume_token(SP);
        interval();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SP:
          ;
          break;
        default:
          jj_la1[3] = jj_gen;
          break label_3;
        }
      }
      output();
      interval();
      break;
    case 120:
      // -----------------------------------------------------------------------------
      // Reverse elementary functions, see P1788/D7.0 Sect. 9.6.5 Table 2
      // -----------------------------------------------------------------------------
      
                      operation = jj_consume_token(120);
      input();
      interval();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SP:
        jj_consume_token(SP);
        interval();
        break;
      default:
        jj_la1[4] = jj_gen;
        ;
      }
      output();
      interval();
      break;
    case 121:
      operation = jj_consume_token(121);
      input();
      interval();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SP:
        jj_consume_token(SP);
        interval();
        break;
      default:
        jj_la1[5] = jj_gen;
        ;
      }
      output();
      interval();
      break;
    case 122:
      operation = jj_consume_token(122);
      input();
      interval();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SP:
        jj_consume_token(SP);
        interval();
        break;
      default:
        jj_la1[6] = jj_gen;
        ;
      }
      output();
      interval();
      break;
    case 123:
      operation = jj_consume_token(123);
      input();
      interval();
      jj_consume_token(SP);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARIABLE_NAME:
      case INTERVAL:
        interval();
        jj_consume_token(SP);
        break;
      default:
        jj_la1[7] = jj_gen;
        ;
      }
      number2();
      output();
      interval();
      break;
    case 124:
      operation = jj_consume_token(124);
      input();
      interval();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SP:
        jj_consume_token(SP);
        interval();
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
      output();
      interval();
      break;
    case 125:
      operation = jj_consume_token(125);
      input();
      interval();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SP:
        jj_consume_token(SP);
        interval();
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
      output();
      interval();
      break;
    case 126:
      operation = jj_consume_token(126);
      input();
      interval();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SP:
        jj_consume_token(SP);
        interval();
        break;
      default:
        jj_la1[10] = jj_gen;
        ;
      }
      output();
      interval();
      break;
    case 127:
      operation = jj_consume_token(127);
      input();
      interval();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SP:
        jj_consume_token(SP);
        interval();
        break;
      default:
        jj_la1[11] = jj_gen;
        ;
      }
      output();
      interval();
      break;
    case 128:
      // reverse versions of binary point functions
      
                      operation = jj_consume_token(128);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SP:
        jj_consume_token(SP);
        interval();
        break;
      default:
        jj_la1[12] = jj_gen;
        ;
      }
      output();
      interval();
      break;
    case 129:
      operation = jj_consume_token(129);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SP:
        jj_consume_token(SP);
        interval();
        break;
      default:
        jj_la1[13] = jj_gen;
        ;
      }
      output();
      interval();
      break;
    case 130:
      operation = jj_consume_token(130);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SP:
        jj_consume_token(SP);
        interval();
        break;
      default:
        jj_la1[14] = jj_gen;
        ;
      }
      output();
      interval();
      break;
    case 131:
      operation = jj_consume_token(131);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SP:
        jj_consume_token(SP);
        interval();
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
      output();
      interval();
      break;
    case 132:
      operation = jj_consume_token(132);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SP:
        jj_consume_token(SP);
        interval();
        break;
      default:
        jj_la1[16] = jj_gen;
        ;
      }
      output();
      interval();
      break;
    case 133:
      operation = jj_consume_token(133);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SP:
        jj_consume_token(SP);
        interval();
        break;
      default:
        jj_la1[17] = jj_gen;
        ;
      }
      output();
      interval();
      break;
    case 134:
      operation = jj_consume_token(134);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SP:
        jj_consume_token(SP);
        interval();
        break;
      default:
        jj_la1[18] = jj_gen;
        ;
      }
      output();
      interval();
      break;
    case 135:
      operation = jj_consume_token(135);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      interval();
      break;
    case 136:
      operation = jj_consume_token(136);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      interval();
      break;
    case 137:
      operation = jj_consume_token(137);
      input();
      interval();
      jj_consume_token(SP);
      number();
      output();
      interval();
      break;
    case 138:
      operation = jj_consume_token(138);
      input();
      interval();
      output();
      interval();
      break;
    case 139:
      operation = jj_consume_token(139);
      input();
      interval();
      output();
      interval();
      break;
    case 140:
      operation = jj_consume_token(140);
      input();
      interval();
      output();
      interval();
      break;
    case 141:
      operation = jj_consume_token(141);
      input();
      interval();
      output();
      interval();
      break;
    case 142:
      operation = jj_consume_token(142);
      input();
      interval();
      output();
      interval();
      break;
    case 143:
      operation = jj_consume_token(143);
      input();
      interval();
      output();
      interval();
      break;
    case 144:
      operation = jj_consume_token(144);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      interval();
      break;
    case 145:
      operation = jj_consume_token(145);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      interval();
      break;
    case 146:
      operation = jj_consume_token(146);
      input();
      interval();
      output();
      interval();
      break;
    case 147:
      operation = jj_consume_token(147);
      input();
      interval();
      output();
      interval();
      break;
    case 148:
      operation = jj_consume_token(148);
      input();
      interval();
      output();
      interval();
      break;
    case 149:
      operation = jj_consume_token(149);
      input();
      interval();
      output();
      interval();
      break;
    case 150:
      operation = jj_consume_token(150);
      input();
      interval();
      output();
      interval();
      break;
    case 151:
      operation = jj_consume_token(151);
      input();
      interval();
      output();
      interval();
      break;
    case 152:
      operation = jj_consume_token(152);
      input();
      interval();
      output();
      interval();
      break;
    case 153:
      operation = jj_consume_token(153);
      input();
      interval();
      jj_consume_token(SP);
      interval();
      output();
      interval();
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(EOL);
    this.operations_.addOperation(operation.image, this.currentOperation_);
    this.currentOperationDescription_ = null;
    this.currentOperationRequired_ = true;
  }

  final public void output() throws ParseException {
    jj_consume_token(CLOSE_PAR_LIST);
          this.currentOperationInputMode_ = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
    case SUBSETEQ:
    case SUBSETNEQ:
    case SUPERSETEQ:
    case SUPERSETNEQ:
      relationOperator();
      break;
    case NG:
      jj_consume_token(NG);
                          this.currentOperation_.negateResult();
      relationOperator();
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void relationOperator() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
      jj_consume_token(EQUAL);
      break;
    case SUBSETEQ:
      jj_consume_token(SUBSETEQ);
                  this.currentOperation_.setSetRelation(Set.SUBSET);
      break;
    case SUBSETNEQ:
      jj_consume_token(SUBSETNEQ);
                  this.currentOperation_.setSetRelation(Set.PROPER_SUBSET);
      break;
    case SUPERSETEQ:
      jj_consume_token(SUPERSETEQ);
                  this.currentOperation_.setSetRelation(Set.SUPERSET);
      break;
    case SUPERSETNEQ:
      jj_consume_token(SUPERSETNEQ);
                  this.currentOperation_.setSetRelation(Set.PROPER_SUPERSET);
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/* ----------------Block comments handling------------------ */
  final public void dslHeaderBlockComment() throws ParseException {
    jj_consume_token(BEGIN_BLOCK_COMMENT);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AUTHOR_TAG:
      case VERSION_TAG:
      case DESCRIPTION_TAG:
      case OPTIONAL_TAG:
        ;
        break;
      default:
        jj_la1[22] = jj_gen;
        break label_4;
      }
      commentTag(false);
    }
  }

  final public void operationBlockComment() throws ParseException {
    jj_consume_token(BEGIN_BLOCK_COMMENT);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AUTHOR_TAG:
      case VERSION_TAG:
      case DESCRIPTION_TAG:
      case OPTIONAL_TAG:
        ;
        break;
      default:
        jj_la1[23] = jj_gen;
        break label_5;
      }
      commentTag(true);
    }
  }

  final public void commentTag(boolean operation) throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AUTHOR_TAG:
      jj_consume_token(AUTHOR_TAG);
      t = jj_consume_token(TAG);
        if (!operation) {
                 dslAuthors = t.image;
        }
      break;
    case VERSION_TAG:
      jj_consume_token(VERSION_TAG);
      t = jj_consume_token(TAG);
        if (!operation) {
                dslVersion = t.image;
        }
      break;
    case DESCRIPTION_TAG:
      jj_consume_token(DESCRIPTION_TAG);
      t = jj_consume_token(TAG);
        if (!operation) {
                 dslDescription = t.image;
        }
        else {
                currentOperationDescription_ = t.image;
        }
      break;
    case OPTIONAL_TAG:
      jj_consume_token(OPTIONAL_TAG);
      t = jj_consume_token(TAG);
                if (operation) {
                        if (t.image.toLowerCase().equals("true")) {
                        currentOperationRequired_ = true;
                        }
                        else if (t.image.toLowerCase().equals("false")){
                                currentOperationRequired_ = false;
                  }
                }
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/* ---------------------Handle Mix Types-------------------- */
  final public void input() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_TYPE:
      getReturnType();
      jj_consume_token(OPEN_PAR_LIST);
      break;
    case OPEN_PAR_LIST:
      jj_consume_token(OPEN_PAR_LIST);
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// look for mixed type declaration
  final public void getReturnType() throws ParseException {
    jj_consume_token(OPEN_TYPE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTERVAL:
      jj_consume_token(INTERVAL);
      jj_consume_token(OPEN_TYPE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FLOAT:
        jj_consume_token(FLOAT);
                                                  this.currentOperation_.setMixedTypeOutput(SinglePrecisionFloat.class);
        break;
      case DOUBLE:
        jj_consume_token(DOUBLE);
                                                  this.currentOperation_.setMixedTypeOutput(DoublePrecisionFloat.class);
        break;
      case SHORT:
        jj_consume_token(SHORT);
                                                  this.currentOperation_.setMixedTypeOutput(Short.class);
        break;
      case INTEGER:
        jj_consume_token(INTEGER);
                                                  this.currentOperation_.setMixedTypeOutput(Integer.class);
        break;
      case LONG:
        jj_consume_token(LONG);
                                                  this.currentOperation_.setMixedTypeOutput(Long.class);
        break;
      default:
        jj_la1[26] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(CLOSE_TYPE);
      break;
    case SHORT:
    case INTEGER:
    case LONG:
    case FLOAT:
    case DOUBLE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOUBLE:
        jj_consume_token(DOUBLE);
                          this.currentOperation_.setMixedTypeOutput(DoublePrecisionFloat.class);
        break;
      case FLOAT:
        jj_consume_token(FLOAT);
                          this.currentOperation_.setMixedTypeOutput(SinglePrecisionFloat.class);
        break;
      case INTEGER:
        jj_consume_token(INTEGER);
                          this.currentOperation_.setMixedTypeOutput(Integer.class);
        break;
      case SHORT:
        jj_consume_token(SHORT);
                          this.currentOperation_.setMixedTypeOutput(Short.class);
        break;
      case LONG:
        jj_consume_token(LONG);
                          this.currentOperation_.setMixedTypeOutput(Long.class);
        break;
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[28] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(CLOSE_TYPE);
  }

/* ---------------------Handle variables-------------------- */

// add new variable with its value
  final public void variable() throws ParseException {
        Token name;
        GenericParameter <?> par;
    name = jj_consume_token(VARIABLE_NAME);
    jj_consume_token(EQUAL);
    par = getParameter();
    jj_consume_token(EOL);
                variables_.put(name.image, par);
  }

// get variable-value by its name
  final public GenericParameter <?> getVariableValue() throws ParseException {
        Token variable;
    variable = jj_consume_token(VARIABLE_NAME);
                lastUsedVariableName_ = variable.image;
                lastUsedVariableLineNumber_ = variable.beginLine;
                lastUsedVariableColumnNumber_ = variable.beginColumn;

                if (variables_.containsKey(lastUsedVariableName_)) {
                        {if (true) return variables_.get(lastUsedVariableName_);}
                }
                else {
                        {if (true) throw new NullPointerException
                                ("\u005cn" + "Variable: \u005c"$" + lastUsedVariableName_
                                + "\u005c" from line: " + lastUsedVariableLineNumber_
                                + ", column: "
                                + lastUsedVariableColumnNumber_ + " is NULL!\u005cn");}
                }
    throw new Error("Missing return statement in function");
  }

  final public String getFalseTypeExceptionMessage(String requiredTypeName,
        String actualTypeName, boolean interval) throws ParseException {
        String exception = "\u005cn" + "Variable: \u005c"$" + lastUsedVariableName_
                        + "\u005c" in line: " + lastUsedVariableLineNumber_ + ", column: "
                        + lastUsedVariableColumnNumber_ + " has a unexpected/false type";
        if (interval) {
                exception += " with current interval ";
        }
        exception += "\u005cn" + "Required type: \u005ct" +
                        requiredTypeName + "\u005cn" + "Actual type: \u005ct"
                        + actualTypeName + "\u005cn";

        {if (true) return exception;}
    throw new Error("Missing return statement in function");
  }

/* ---------------Handle primitive data type---------------- */
  final public GenericParameter <?> getParameter() throws ParseException {
        Short shortParam = null;
        Integer integerParam = null;
        Long longParam = null;
        SinglePrecisionFloat floatParam = null;
        DoublePrecisionFloat doubleParam = null;
        Boolean boolParam = null;
        Interval<?> intervalParam = null;

        Endpoints infinityParam = null;
        Endpoints emptySetParam = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SHORT:
      jj_consume_token(SHORT);
      jj_consume_token(PRIMITIVE_PAR_SEP);
      shortParam = getShortValue();
          {if (true) return new GenericParameter<Short>(shortParam);}
      break;
    case INTEGER:
      jj_consume_token(INTEGER);
      jj_consume_token(PRIMITIVE_PAR_SEP);
      integerParam = getIntegerValue();
          {if (true) return new GenericParameter<Integer>(integerParam);}
      break;
    case LONG:
      jj_consume_token(LONG);
      jj_consume_token(PRIMITIVE_PAR_SEP);
      longParam = getLongValue();
          {if (true) return new GenericParameter<Long>(longParam);}
      break;
    case FLOAT:
      jj_consume_token(FLOAT);
      jj_consume_token(PRIMITIVE_PAR_SEP);
      floatParam = getSinglePrecisionFloatValue();
          {if (true) return new GenericParameter<SinglePrecisionFloat>(floatParam);}
      break;
    case DOUBLE:
      jj_consume_token(DOUBLE);
      jj_consume_token(PRIMITIVE_PAR_SEP);
      doubleParam = getDoublePrecisionFloatValue();
          {if (true) return new GenericParameter<DoublePrecisionFloat>(doubleParam);}
      break;
    case BOOL:
    case BOOL_TRUE:
    case BOOL_FALSE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOL:
        jj_consume_token(BOOL);
        jj_consume_token(PRIMITIVE_PAR_SEP);
        break;
      default:
        jj_la1[29] = jj_gen;
        ;
      }
      boolParam = getBoolValue();
          {if (true) return new GenericParameter<Boolean>(boolParam);}
      break;
    case INTERVAL:
      intervalParam = getIntervalParameter();
          {if (true) return new GenericParameter<Interval<?>>(intervalParam);}
      break;
    case NEGATIVE_INFINITY:
    case POSITIVE_INFINITY:
      infinityParam = getInfinityValue();
          {if (true) return new GenericParameter<Endpoints>(infinityParam);}
      break;
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Endpoints getInfinityValue() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NEGATIVE_INFINITY:
      jj_consume_token(NEGATIVE_INFINITY);
          {if (true) return Endpoints.NEGATIVE_INFINITY;}
      break;
    case POSITIVE_INFINITY:
      jj_consume_token(POSITIVE_INFINITY);
          {if (true) return Endpoints.POSITIVE_INFINITY;}
      break;
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Boolean getBoolValue() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOL_TRUE:
      jj_consume_token(BOOL_TRUE);
                        {if (true) return true;}
      break;
    case BOOL_FALSE:
      jj_consume_token(BOOL_FALSE);
                                                          {if (true) return true;}
      break;
    default:
      jj_la1[32] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public DoublePrecisionFloat getDoublePrecisionFloatValue() throws ParseException {
        Token value;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HEX_16:
      value = jj_consume_token(HEX_16);
      break;
    case BIN_64:
      value = jj_consume_token(BIN_64);
      break;
    case DIGITS_INTEGER:
      value = jj_consume_token(DIGITS_INTEGER);
      break;
    case DIGITS_FLOAT:
      value = jj_consume_token(DIGITS_FLOAT);
      break;
    default:
      jj_la1[33] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          {if (true) return new DoublePrecisionFloat(value.image);}
    throw new Error("Missing return statement in function");
  }

  final public SinglePrecisionFloat getSinglePrecisionFloatValue() throws ParseException {
        Token value;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HEX_8:
      value = jj_consume_token(HEX_8);
      break;
    case BIN_32:
      value = jj_consume_token(BIN_32);
      break;
    case DIGITS_INTEGER:
      value = jj_consume_token(DIGITS_INTEGER);
      break;
    case DIGITS_FLOAT:
      value = jj_consume_token(DIGITS_FLOAT);
      break;
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          {if (true) return new SinglePrecisionFloat(value.image);}
    throw new Error("Missing return statement in function");
  }

  final public Short getShortValue() throws ParseException {
        Token value;
    value = jj_consume_token(DIGITS_INTEGER);
          {if (true) return Short.valueOf(value.image);}
    throw new Error("Missing return statement in function");
  }

  final public Integer getIntegerValue() throws ParseException {
        Token value;
    value = jj_consume_token(DIGITS_INTEGER);
          {if (true) return Integer.valueOf(value.image);}
    throw new Error("Missing return statement in function");
  }

  final public Long getLongValue() throws ParseException {
        Token value;
    value = jj_consume_token(DIGITS_INTEGER);
          {if (true) return Long.valueOf(value.image);}
    throw new Error("Missing return statement in function");
  }

/* ----------Handle paramers given in an operation---------- */
  final public void bool() throws ParseException {
        GenericParameter <?> variable = null;
        Boolean bool = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOL_TRUE:
    case BOOL_FALSE:
      bool = getBoolValue();
      addParameterToFunction(new GenericParameter<Boolean> (bool));
      break;
    case VARIABLE_NAME:
      variable = getVariableValue();
                        if (variable.hasType(Boolean.class)) {
                                addParameterToFunction(variable);
                        }
                        else {
                                {if (true) throw new ParseException(
                                        getFalseTypeExceptionMessage("Boolean" ,
                                        variable.getTypeClass().getSimpleName(), false));}
                        }
      break;
    default:
      jj_la1[35] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void number() throws ParseException {
        GenericParameter <?> variable = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOAT:
    case DOUBLE:
      floatingPoint();
      break;
    case SHORT:
    case INTEGER:
    case LONG:
      integer();
      break;
    case VARIABLE_NAME:
      variable = getVariableValue();
                        if (variable.hasType(FloatingPoint.class) || variable.hasType(Number.class)) {
                                addParameterToFunction(variable);
                        }
                        else {
                                {if (true) throw new ParseException(
                                        getFalseTypeExceptionMessage("Short, Integer Long, "
                                        + "SinglePrecisionFloat or DoublePrecisionFloat",
                                        variable.getTypeClass().getSimpleName(), false));}
                        }
      break;
    default:
      jj_la1[36] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void number2() throws ParseException {
        GenericParameter <?> variable = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOAT:
    case DOUBLE:
      floatingPoint();
      break;
    case SHORT:
    case INTEGER:
    case LONG:
      integer();
      break;
    default:
      jj_la1[37] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void floatingPoint() throws ParseException {
        FloatingPoint fp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOAT:
      jj_consume_token(FLOAT);
      jj_consume_token(PRIMITIVE_PAR_SEP);
      fp = getSinglePrecisionFloatValue();
      break;
    case DOUBLE:
      jj_consume_token(DOUBLE);
      jj_consume_token(PRIMITIVE_PAR_SEP);
      fp = getDoublePrecisionFloatValue();
      addParameterToFunction(new GenericParameter<FloatingPoint> (fp));
      break;
    default:
      jj_la1[38] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void integer() throws ParseException {
        Number num = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SHORT:
      jj_consume_token(SHORT);
      jj_consume_token(PRIMITIVE_PAR_SEP);
      num = getShortValue();
      break;
    case INTEGER:
      jj_consume_token(INTEGER);
      jj_consume_token(PRIMITIVE_PAR_SEP);
      num = getIntegerValue();
      break;
    case LONG:
      jj_consume_token(LONG);
      jj_consume_token(PRIMITIVE_PAR_SEP);
      num = getLongValue();
      break;
    default:
      jj_la1[39] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    addParameterToFunction(new GenericParameter<Number> (num));
  }

  final public void interval() throws ParseException {
        GenericParameter <?> variable = null;
        Interval<?> interval = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTERVAL:
      interval = getIntervalParameter();
      addParameterToFunction(new GenericParameter<Interval<?>> (interval));
      break;
    case VARIABLE_NAME:
      variable = getVariableValue();
                if (variable.hasType(Interval.class)) {
                        addParameterToFunction(variable);
                }
                else {
                        {if (true) throw new ParseException(
                                getFalseTypeExceptionMessage(Interval.class.getName(),
                                variable.getTypeClass().getSimpleName(), false));}
                }
      break;
    default:
      jj_la1[40] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void addParameterToFunction(GenericParameter<?> param) throws ParseException {
    if (this.currentOperationInputMode_)
    {
      currentOperation_.addInputParameter(param);
    }
    else
    {
      currentOperation_.addOutputParameter(param);
    }
  }

/* -----------------Handle interval-type-------------------- */
  final public Interval<?> getIntervalParameter() throws ParseException {
        Interval<FloatingPoint> intervalFloat = new Interval<FloatingPoint>(FloatingPoint.class);
        Interval<Number> intervalInteger = new Interval<Number>(Number.class);

        FloatingPoint floatValue = null;
        Number integerValue = null;
    jj_consume_token(INTERVAL);
    jj_consume_token(OPEN_TYPE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOAT:
      jj_consume_token(FLOAT);
      jj_consume_token(CLOSE_TYPE);
      jj_consume_token(OPEN_INTERVAL_VARS);
                  intervalFloat.specifySubclass(SinglePrecisionFloat.class);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARIABLE_NAME:
      case DIGITS_INTEGER:
      case DIGITS_FLOAT:
      case BIN_32:
      case HEX_8:
      case NEGATIVE_INFINITY:
      case POSITIVE_INFINITY:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DIGITS_INTEGER:
        case DIGITS_FLOAT:
        case BIN_32:
        case HEX_8:
          floatValue = getSinglePrecisionFloatValue();
                                  intervalFloat.setLower_limit(floatValue);
          break;
        case VARIABLE_NAME:
        case NEGATIVE_INFINITY:
        case POSITIVE_INFINITY:
          handleEndpointsAndVariablesForFloat(intervalFloat, true);
          break;
        default:
          jj_la1[41] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(SP);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DIGITS_INTEGER:
        case DIGITS_FLOAT:
        case BIN_32:
        case HEX_8:
          floatValue = getSinglePrecisionFloatValue();
                                 intervalFloat.setUpper_limit(floatValue);
          break;
        case VARIABLE_NAME:
        case NEGATIVE_INFINITY:
        case POSITIVE_INFINITY:
          handleEndpointsAndVariablesForFloat(intervalFloat, false);
          break;
        default:
          jj_la1[42] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case EMPTY_SET:
        jj_consume_token(EMPTY_SET);
                          intervalFloat.emptyInterval();
        break;
      case ENTIRE_SET:
        jj_consume_token(ENTIRE_SET);
                          intervalFloat.setEntireInterval();
        break;
      default:
        jj_la1[43] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(CLOSE_INTERVAL_VARS);
                  {if (true) return intervalFloat;}
      break;
    case DOUBLE:
      jj_consume_token(DOUBLE);
      jj_consume_token(CLOSE_TYPE);
      jj_consume_token(OPEN_INTERVAL_VARS);
                  intervalFloat.specifySubclass(DoublePrecisionFloat.class);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARIABLE_NAME:
      case DIGITS_INTEGER:
      case DIGITS_FLOAT:
      case BIN_64:
      case HEX_16:
      case NEGATIVE_INFINITY:
      case POSITIVE_INFINITY:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DIGITS_INTEGER:
        case DIGITS_FLOAT:
        case BIN_64:
        case HEX_16:
          floatValue = getDoublePrecisionFloatValue();
                                  intervalFloat.setLower_limit(floatValue);
          break;
        case VARIABLE_NAME:
        case NEGATIVE_INFINITY:
        case POSITIVE_INFINITY:
          handleEndpointsAndVariablesForFloat(intervalFloat, true);
          break;
        default:
          jj_la1[44] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(SP);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DIGITS_INTEGER:
        case DIGITS_FLOAT:
        case BIN_64:
        case HEX_16:
          floatValue = getDoublePrecisionFloatValue();
                                 intervalFloat.setUpper_limit(floatValue);
          break;
        case VARIABLE_NAME:
        case NEGATIVE_INFINITY:
        case POSITIVE_INFINITY:
          handleEndpointsAndVariablesForFloat(intervalFloat, false);
          break;
        default:
          jj_la1[45] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case EMPTY_SET:
        jj_consume_token(EMPTY_SET);
                          intervalFloat.emptyInterval();
        break;
      case ENTIRE_SET:
        jj_consume_token(ENTIRE_SET);
                          intervalFloat.setEntireInterval();
        break;
      default:
        jj_la1[46] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(CLOSE_INTERVAL_VARS);
                  {if (true) return intervalFloat;}
      break;
    case SHORT:
      jj_consume_token(SHORT);
      jj_consume_token(CLOSE_TYPE);
      jj_consume_token(OPEN_INTERVAL_VARS);
                  intervalInteger.specifySubclass(Short.class);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARIABLE_NAME:
      case DIGITS_INTEGER:
      case NEGATIVE_INFINITY:
      case POSITIVE_INFINITY:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DIGITS_INTEGER:
          integerValue = getShortValue();
                                  intervalInteger.setLower_limit(integerValue);
          break;
        case VARIABLE_NAME:
        case NEGATIVE_INFINITY:
        case POSITIVE_INFINITY:
          handleEndpointsAndVariablesForInteger(intervalInteger, true);
          break;
        default:
          jj_la1[47] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(SP);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DIGITS_INTEGER:
          integerValue = getShortValue();
                                 intervalInteger.setUpper_limit(integerValue);
          break;
        case VARIABLE_NAME:
        case NEGATIVE_INFINITY:
        case POSITIVE_INFINITY:
          handleEndpointsAndVariablesForInteger(intervalInteger, false);
          break;
        default:
          jj_la1[48] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case EMPTY_SET:
        jj_consume_token(EMPTY_SET);
                          intervalFloat.emptyInterval();
        break;
      case ENTIRE_SET:
        jj_consume_token(ENTIRE_SET);
                          intervalFloat.setEntireInterval();
        break;
      default:
        jj_la1[49] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(CLOSE_INTERVAL_VARS);
                  {if (true) return intervalInteger;}
      break;
    case INTEGER:
    case ENTIRE_SET:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER:
        jj_consume_token(INTEGER);
        jj_consume_token(CLOSE_TYPE);
        jj_consume_token(OPEN_INTERVAL_VARS);
                  intervalInteger.specifySubclass(Integer.class);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VARIABLE_NAME:
        case DIGITS_INTEGER:
        case NEGATIVE_INFINITY:
        case POSITIVE_INFINITY:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DIGITS_INTEGER:
            integerValue = getIntegerValue();
                                  intervalInteger.setLower_limit(integerValue);
            break;
          case VARIABLE_NAME:
          case NEGATIVE_INFINITY:
          case POSITIVE_INFINITY:
            handleEndpointsAndVariablesForInteger(intervalInteger, true);
            break;
          default:
            jj_la1[50] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          jj_consume_token(SP);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DIGITS_INTEGER:
            integerValue = getIntegerValue();
                                 intervalInteger.setUpper_limit(integerValue);
            break;
          case VARIABLE_NAME:
          case NEGATIVE_INFINITY:
          case POSITIVE_INFINITY:
            handleEndpointsAndVariablesForInteger(intervalInteger, false);
            break;
          default:
            jj_la1[51] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        case EMPTY_SET:
          jj_consume_token(EMPTY_SET);
                          intervalFloat.emptyInterval();
          break;
        default:
          jj_la1[52] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case ENTIRE_SET:
        jj_consume_token(ENTIRE_SET);
                          intervalFloat.setEntireInterval();
        jj_consume_token(CLOSE_INTERVAL_VARS);
                  {if (true) return intervalInteger;}
        break;
      default:
        jj_la1[53] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case LONG:
      jj_consume_token(LONG);
      jj_consume_token(CLOSE_TYPE);
      jj_consume_token(OPEN_INTERVAL_VARS);
                  intervalInteger.specifySubclass(Long.class);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARIABLE_NAME:
      case DIGITS_INTEGER:
      case NEGATIVE_INFINITY:
      case POSITIVE_INFINITY:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DIGITS_INTEGER:
          integerValue = getLongValue();
                                  intervalInteger.setLower_limit(integerValue);
          break;
        case VARIABLE_NAME:
        case NEGATIVE_INFINITY:
        case POSITIVE_INFINITY:
          handleEndpointsAndVariablesForInteger(intervalInteger, true);
          break;
        default:
          jj_la1[54] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(SP);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DIGITS_INTEGER:
          integerValue = getLongValue();
                                 intervalInteger.setUpper_limit(integerValue);
          break;
        case VARIABLE_NAME:
        case NEGATIVE_INFINITY:
        case POSITIVE_INFINITY:
          handleEndpointsAndVariablesForInteger(intervalInteger, false);
          break;
        default:
          jj_la1[55] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case EMPTY_SET:
        jj_consume_token(EMPTY_SET);
                          intervalFloat.emptyInterval();
        break;
      case ENTIRE_SET:
        jj_consume_token(ENTIRE_SET);
                          intervalFloat.setEntireInterval();
        break;
      default:
        jj_la1[56] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(CLOSE_INTERVAL_VARS);
                  {if (true) return intervalInteger;}
      break;
    default:
      jj_la1[57] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void handleEndpointsAndVariablesForFloat(Interval<FloatingPoint> interval, boolean lower) throws ParseException {
        GenericParameter <?> variable = null;
        Endpoints EndpointsValue = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VARIABLE_NAME:
      variable = getVariableValue();
                Class<?> intervalClass = interval.getTypeClass();
                if (variable.hasType(intervalClass)) {
                        if (lower) {
                                interval.setLower_limit((FloatingPoint) variable.getValue());
                        } else {
                                interval.setUpper_limit((FloatingPoint) variable.getValue());
                        }
                }
                else if (variable.hasType(Endpoints.class)) {
                        EndpointsValue = (Endpoints) variable.getValue();
                }
                else {
                        {if (true) throw new ParseException(
                                getFalseTypeExceptionMessage(intervalClass.getName(),
                                variable.getTypeClass().getSimpleName(), true));}
                }
      break;
    case NEGATIVE_INFINITY:
    case POSITIVE_INFINITY:
      EndpointsValue = getInfinityValue();
      break;
    default:
      jj_la1[58] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                if (EndpointsValue != null) {
                        if (lower) {
                                interval.setLowerEndpoint(EndpointsValue);
                        } else {
                                interval.setUpperEndpoint(EndpointsValue);
                        }
                }
  }

  final public void handleEndpointsAndVariablesForInteger(Interval<Number> interval, boolean lower) throws ParseException {
        GenericParameter <?> variable = null;
        Endpoints EndpointsValue = null, emptySet = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VARIABLE_NAME:
      variable = getVariableValue();
                Class<?> intervalClass = interval.getTypeClass();
                if (variable.hasType(intervalClass)) {
                        if (lower) {
                                interval.setLower_limit((Number) variable.getValue());
                        } else {
                                interval.setUpper_limit((Number) variable.getValue());
                        }
                }
                else if (variable.hasType(Endpoints.class)) {
                        EndpointsValue = (Endpoints) variable.getValue();
                }
                else {
                        {if (true) throw new ParseException(
                                getFalseTypeExceptionMessage(intervalClass.getName(),
                                variable.getTypeClass().getSimpleName(), true));}
                }
      break;
    case NEGATIVE_INFINITY:
    case POSITIVE_INFINITY:
      EndpointsValue = getInfinityValue();
      break;
    default:
      jj_la1[59] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                if (EndpointsValue != null) {
                        if (lower) {
                                interval.setLowerEndpoint(EndpointsValue);
                        } else {
                                interval.setUpperEndpoint(EndpointsValue);
                        }
                }
  }

  /** Generated Token Manager. */
  public DSLParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[60];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
      jj_la1_init_4();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x40040,0x40040,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1e00,0x1e00,0x1e00,0x0,0x1b80000,0x1b80000,0x1b80000,0x40000000,0xc1b80000,0x0,0x80000000,0x2a400000,0x16400000,0x80040000,0x1bc0000,0x1b80000,0x1800000,0x380000,0x40000,0x16440000,0x16440000,0x16440000,0x2a440000,0x2a440000,0x2a440000,0x440000,0x440000,0x440000,0x440000,0x440000,0x440000,0x100000,0x440000,0x440000,0x440000,0x1b80000,0x40000,0x40000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0xffe00000,0xffe00000,0x400,0x400,0x400,0x400,0x400,0x2,0x400,0x400,0x400,0x400,0x400,0x400,0x400,0x400,0x400,0x400,0x400,0xffe00000,0xfa00,0xf200,0x0,0x0,0x0,0x10100,0x0,0x0,0x2,0x0,0xf,0xc,0x1,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x2,0xc,0xc,0x3c,0xc,0xc,0x3c,0xc,0xc,0x3c,0xc,0xc,0x1c,0x20,0xc,0xc,0x3c,0x20,0xc,0xc,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0xffffffff,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0xffffffff,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_4() {
      jj_la1_4 = new int[] {0x3ffffff,0x3ffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3ffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }

  /** Constructor with InputStream. */
  public DSLParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public DSLParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new DSLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 60; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 60; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public DSLParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new DSLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 60; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 60; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public DSLParser(DSLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 60; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(DSLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 60; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[154];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 60; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 154; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
