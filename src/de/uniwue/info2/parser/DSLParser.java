/* Generated By:JavaCC: Do not edit this line. DSLParser.java */
package de.uniwue.info2.parser;
import de.uniwue.info2.numerics.FloatingPoint;
import de.uniwue.info2.numerics.prec.DoublePrecisionFloat;
import de.uniwue.info2.numerics.prec.SinglePrecisionFloat;
import de.uniwue.info2.operations.GenericParameter;
import de.uniwue.info2.operations.Interval;
import de.uniwue.info2.operations.Operation;
import de.uniwue.info2.generator.OperationsPool;
import de.uniwue.info2.operations.Endpoints;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.HashMap;


/**
 * Parser for the Domain Specific Language.
 * 
 * @author Michael Jedich
 */

@SuppressWarnings("unused")
public class DSLParser implements DSLParserConstants {
  // dsl information, updated by the dsl
  private static String dslAuthors, dslVersion, dslDescription;


  // information for generated parser
  // if parser has been modified, update this information:
  private final static String parserDescription =
                "Early Version of Parser Generator";
  private final static String parserVersion = "0.8";
  private final static String parserAuthors = "Michael Jedich";

  // variables specified in the dsl
  private HashMap<String, GenericParameter<?>> variables_;

  // operations specified in the dsl
  private OperationsPool operations_;

  // current operation found in the dsl
  private Operation currentOperation_;
  private String currentOperationDescription_ = null;
  private boolean currentOperationRequired_ = true;
  private boolean currentOperationInputMode_ = true;


  // used for an exception message when handling variables
  private String lastUsedVariableName_;
  private int lastUsedVariableLineNumber_;
  private int lastUsedVariableColumnNumber_;

  /**
   * DSL-Parser constructor.
   * 
   * @param dslFile
   *            given Domain Specific Language - File
   * @throws FileNotFoundException
   */
  public DSLParser(File dslFile) throws FileNotFoundException
  {
    this (new FileReader(dslFile));
    this.operations_ = new OperationsPool();
    variables_ = new HashMap<String, GenericParameter<?>>();
  }

  /**
   * Get authors specified in the Domain Specific Language.
   * 
   * @return DSL authors in single String
   */
  public String getDslAuthors()
  {
    return dslAuthors;
  }

  /**
   * Get version of Domain Specific Language.
   * 
   * @return DSL version as String
   */
  public String getDslVersion()
  {
    return dslVersion;
  }

  /**
   * Get description of Domain Specific Language.
   * 
   * @return DSL description
   */
  public String getDslDescription()
  {
    return dslDescription;
  }

  /**
   * Get description of current parser.
   * 
   * @return Parser description
   */
  public static String getParserDescription()
  {
    return parserDescription;
  }

  /**
   * Get version of current parser.
   * 
   * @return Parser version
   */
  public static String getParserVersion()
  {
    return parserVersion;
  }

  /**
   * Get authors of current parser.
   * 
   * @return Parser authors in single String.
   */
  public static String getParserAuthors()
  {
    return parserAuthors;
  }

/* --------------------------------------------------------- */
/* ------------------GRAMMER-SPECIFICATION------------------ */
/* --------------------------------------------------------- */

// main grammer
  final public OperationsPool parse() throws ParseException {
    dslHeaderBlockComment();
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BEGIN_BLOCK_COMMENT:
      case VARIABLE_NAME:
      case 38:
      case 42:
      case 43:
      case 45:
      case 46:
      case 47:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BEGIN_BLOCK_COMMENT:
        operationBlockComment();
        break;
      case VARIABLE_NAME:
        variable();
        break;
      case 38:
      case 42:
      case 43:
      case 45:
      case 46:
      case 47:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
        operation();
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(0);
                // return extracted operations of given Domain-Specific-Language
                {if (true) return operations_;}
    throw new Error("Missing return statement in function");
  }

/* ----------------Define operations here:------------------ */
  final public void operation() throws ParseException {
  Token operation;
  this.currentOperation_ = new Operation();
  this.currentOperation_.setDescription(this.currentOperationDescription_);
  this.currentOperation_.setRequired(this.currentOperationRequired_);
  this.currentOperationInputMode_ = true;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 38:
      operation = jj_consume_token(38);
      jj_consume_token(39);
      interval();
      jj_consume_token(40);
      switchToOutput();
      jj_consume_token(41);
      interval();
      break;
    case 42:
      operation = jj_consume_token(42);
      jj_consume_token(39);
      interval();
      jj_consume_token(40);
      switchToOutput();
      jj_consume_token(41);
      interval();
      break;
    case 43:
      operation = jj_consume_token(43);
      jj_consume_token(39);
      interval();
      jj_consume_token(44);
      interval();
      jj_consume_token(40);
      switchToOutput();
      jj_consume_token(41);
      interval();
      break;
    case 45:
      operation = jj_consume_token(45);
      jj_consume_token(39);
      interval();
      jj_consume_token(44);
      interval();
      jj_consume_token(40);
      switchToOutput();
      jj_consume_token(41);
      interval();
      break;
    case 46:
      operation = jj_consume_token(46);
      jj_consume_token(39);
      interval();
      jj_consume_token(44);
      interval();
      jj_consume_token(40);
      switchToOutput();
      jj_consume_token(41);
      interval();
      break;
    case 47:
      operation = jj_consume_token(47);
      jj_consume_token(39);
      interval();
      jj_consume_token(44);
      interval();
      jj_consume_token(40);
      switchToOutput();
      jj_consume_token(41);
      interval();
      break;
    case 48:
      operation = jj_consume_token(48);
      jj_consume_token(39);
      interval();
      jj_consume_token(40);
      switchToOutput();
      jj_consume_token(41);
      interval();
      break;
    case 49:
      operation = jj_consume_token(49);
      jj_consume_token(39);
      interval();
      jj_consume_token(40);
      switchToOutput();
      jj_consume_token(41);
      interval();
      break;
    case 50:
      operation = jj_consume_token(50);
      jj_consume_token(39);
      interval();
      jj_consume_token(44);
      interval();
      jj_consume_token(44);
      interval();
      jj_consume_token(40);
      switchToOutput();
      jj_consume_token(41);
      interval();
      break;
    case 51:
      operation = jj_consume_token(51);
      jj_consume_token(39);
      interval();
      jj_consume_token(44);
      interval();
      jj_consume_token(44);
      interval();
      jj_consume_token(40);
      switchToOutput();
      jj_consume_token(41);
      interval();
      break;
    case 52:
      operation = jj_consume_token(52);
      jj_consume_token(39);
      interval();
      jj_consume_token(40);
      switchToOutput();
      jj_consume_token(41);
      number();
      break;
    case 53:
      operation = jj_consume_token(53);
      jj_consume_token(39);
      number();
      jj_consume_token(44);
      interval();
      jj_consume_token(40);
      switchToOutput();
      jj_consume_token(41);
      bool();
      break;
    case 54:
      operation = jj_consume_token(54);
      jj_consume_token(39);
      interval();
      jj_consume_token(40);
      switchToOutput();
      jj_consume_token(41);
      interval();
      jj_consume_token(44);
      interval();
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(EOL);
    this.operations_.addOperation(operation.image, this.currentOperation_);
    this.currentOperationDescription_ = null;
    this.currentOperationRequired_ = true;
  }

  final public void switchToOutput() throws ParseException {
   this.currentOperationInputMode_ = false;
  }

/* ----------------Block comments handling------------------ */
  final public void dslHeaderBlockComment() throws ParseException {
    jj_consume_token(BEGIN_BLOCK_COMMENT);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AUTHOR_TAG:
      case VERSION_TAG:
      case DESCRIPTION_TAG:
      case OPTIONAL_TAG:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_2;
      }
      commentTag(false);
    }
  }

  final public void operationBlockComment() throws ParseException {
    jj_consume_token(BEGIN_BLOCK_COMMENT);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AUTHOR_TAG:
      case VERSION_TAG:
      case DESCRIPTION_TAG:
      case OPTIONAL_TAG:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_3;
      }
      commentTag(true);
    }
  }

  final public void commentTag(boolean operation) throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AUTHOR_TAG:
      jj_consume_token(AUTHOR_TAG);
      t = jj_consume_token(TAG);
        if (!operation) {
                 dslAuthors = t.image;
        }
      break;
    case VERSION_TAG:
      jj_consume_token(VERSION_TAG);
      t = jj_consume_token(TAG);
        if (!operation) {
                dslVersion = t.image;
        }
      break;
    case DESCRIPTION_TAG:
      jj_consume_token(DESCRIPTION_TAG);
      t = jj_consume_token(TAG);
        if (!operation) {
                 dslDescription = t.image;
        }
        else {
                currentOperationDescription_ = t.image;
        }
      break;
    case OPTIONAL_TAG:
      jj_consume_token(OPTIONAL_TAG);
      t = jj_consume_token(TAG);
                if (operation) {
                        if (t.image.toLowerCase().equals("true")) {
                        currentOperationRequired_ = true;
                        }
                        else if (t.image.toLowerCase().equals("false")){
                                currentOperationRequired_ = false;
                  }
                }
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/* ---------------------Handle variables-------------------- */

// add new variable with its value
  final public void variable() throws ParseException {
        Token name;
        GenericParameter <?> par;
    name = jj_consume_token(VARIABLE_NAME);
    jj_consume_token(41);
    par = getParameter();
    jj_consume_token(EOL);
                variables_.put(name.image, par);
  }

// get variable-value by its name
  final public GenericParameter <?> getVariableValue() throws ParseException {
        Token variable;
    variable = jj_consume_token(VARIABLE_NAME);
                lastUsedVariableName_ = variable.image;
                lastUsedVariableLineNumber_ = variable.beginLine;
                lastUsedVariableColumnNumber_ = variable.beginColumn;

                if (variables_.containsKey(lastUsedVariableName_)) {
                        {if (true) return variables_.get(lastUsedVariableName_);}
                }
                else {
                        {if (true) throw new NullPointerException
                                ("\u005cn" + "Variable: \u005c"$" + lastUsedVariableName_
                                + "\u005c" from line: " + lastUsedVariableLineNumber_
                                + ", column: "
                                + lastUsedVariableColumnNumber_ + " is NULL!\u005cn");}
                }
    throw new Error("Missing return statement in function");
  }

  final public String getFalseTypeExceptionMessage(String requiredTypeName,
        String actualTypeName, boolean interval) throws ParseException {
        String exception = "\u005cn" + "Variable: \u005c"$" + lastUsedVariableName_
                        + "\u005c" in line: " + lastUsedVariableLineNumber_ + ", column: "
                        + lastUsedVariableColumnNumber_ + " has a unexpected/false type";
        if (interval) {
                exception += " with current interval ";
        }
        exception += "\u005cn" + "Required type: \u005ct" +
                        requiredTypeName + "\u005cn" + "Actual type: \u005ct"
                        + actualTypeName + "\u005cn";

        {if (true) return exception;}
    throw new Error("Missing return statement in function");
  }

/* ---------------Handle primitive data type---------------- */
  final public GenericParameter <?> getParameter() throws ParseException {
        Short shortParam = null;
        Integer integerParam = null;
        Long longParam = null;
        SinglePrecisionFloat floatParam = null;
        DoublePrecisionFloat doubleParam = null;
        Boolean boolParam = null;
        Interval<?> intervalParam = null;

        Endpoints infinityParam = null;
        Endpoints emptySetParam = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SHORT:
      jj_consume_token(SHORT);
      jj_consume_token(55);
      shortParam = getShortValue();
          {if (true) return new GenericParameter<Short>(shortParam);}
      break;
    case INTEGER:
      jj_consume_token(INTEGER);
      jj_consume_token(55);
      integerParam = getIntegerValue();
          {if (true) return new GenericParameter<Integer>(integerParam);}
      break;
    case LONG:
      jj_consume_token(LONG);
      jj_consume_token(55);
      longParam = getLongValue();
          {if (true) return new GenericParameter<Long>(longParam);}
      break;
    case FLOAT:
      jj_consume_token(FLOAT);
      jj_consume_token(55);
      floatParam = getSinglePrecisionFloatValue();
          {if (true) return new GenericParameter<SinglePrecisionFloat>(floatParam);}
      break;
    case DOUBLE:
      jj_consume_token(DOUBLE);
      jj_consume_token(55);
      doubleParam = getDoublePrecisionFloatValue();
          {if (true) return new GenericParameter<DoublePrecisionFloat>(doubleParam);}
      break;
    case BOOL:
    case BOOL_TRUE:
    case BOOL_FALSE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOL:
        jj_consume_token(BOOL);
        jj_consume_token(55);
        break;
      default:
        jj_la1[6] = jj_gen;
        ;
      }
      boolParam = getBoolValue();
          {if (true) return new GenericParameter<Boolean>(boolParam);}
      break;
    case INTERVAL:
      intervalParam = getIntervalParameter();
          {if (true) return new GenericParameter<Interval<?>>(intervalParam);}
      break;
    case NEGATIVE_INFINITY:
    case POSITIVE_INFINITY:
      infinityParam = getInfinityValue();
          {if (true) return new GenericParameter<Endpoints>(infinityParam);}
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Endpoints getInfinityValue() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NEGATIVE_INFINITY:
      jj_consume_token(NEGATIVE_INFINITY);
          {if (true) return Endpoints.NEGATIVE_INFINITY;}
      break;
    case POSITIVE_INFINITY:
      jj_consume_token(POSITIVE_INFINITY);
          {if (true) return Endpoints.POSITIVE_INFINITY;}
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Boolean getBoolValue() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOL_TRUE:
      jj_consume_token(BOOL_TRUE);
                        {if (true) return true;}
      break;
    case BOOL_FALSE:
      jj_consume_token(BOOL_FALSE);
                                                          {if (true) return true;}
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public DoublePrecisionFloat getDoublePrecisionFloatValue() throws ParseException {
        Token value;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HEX_16:
      value = jj_consume_token(HEX_16);
      break;
    case BIN_64:
      value = jj_consume_token(BIN_64);
      break;
    case DIGITS_INTEGER:
      value = jj_consume_token(DIGITS_INTEGER);
      break;
    case DIGITS_FLOAT:
      value = jj_consume_token(DIGITS_FLOAT);
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          {if (true) return new DoublePrecisionFloat(value.image);}
    throw new Error("Missing return statement in function");
  }

  final public SinglePrecisionFloat getSinglePrecisionFloatValue() throws ParseException {
        Token value;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HEX_8:
      value = jj_consume_token(HEX_8);
      break;
    case BIN_32:
      value = jj_consume_token(BIN_32);
      break;
    case DIGITS_INTEGER:
      value = jj_consume_token(DIGITS_INTEGER);
      break;
    case DIGITS_FLOAT:
      value = jj_consume_token(DIGITS_FLOAT);
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          {if (true) return new SinglePrecisionFloat(value.image);}
    throw new Error("Missing return statement in function");
  }

  final public Short getShortValue() throws ParseException {
        Token value;
    value = jj_consume_token(DIGITS_INTEGER);
          {if (true) return Short.valueOf(value.image);}
    throw new Error("Missing return statement in function");
  }

  final public Integer getIntegerValue() throws ParseException {
        Token value;
    value = jj_consume_token(DIGITS_INTEGER);
          {if (true) return Integer.valueOf(value.image);}
    throw new Error("Missing return statement in function");
  }

  final public Long getLongValue() throws ParseException {
        Token value;
    value = jj_consume_token(DIGITS_INTEGER);
          {if (true) return Long.valueOf(value.image);}
    throw new Error("Missing return statement in function");
  }

/* ----------Handle paramers given in an operation---------- */
  final public void bool() throws ParseException {
        GenericParameter <?> variable = null;
        Boolean bool = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOL_TRUE:
    case BOOL_FALSE:
      bool = getBoolValue();
      addParameterToFunction(new GenericParameter<Boolean> (bool));
      break;
    case VARIABLE_NAME:
      variable = getVariableValue();
                        if (variable.hasType(Boolean.class)) {
                                addParameterToFunction(variable);
                        }
                        else {
                                {if (true) throw new ParseException(
                                        getFalseTypeExceptionMessage("Boolean" ,
                                        variable.getTypeClass().getSimpleName(), false));}
                        }
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void number() throws ParseException {
        GenericParameter <?> variable = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOAT:
    case DOUBLE:
      floatingPoint();
      break;
    case SHORT:
    case INTEGER:
    case LONG:
      integer();
      break;
    case VARIABLE_NAME:
      variable = getVariableValue();
                        if (variable.hasType(FloatingPoint.class) || variable.hasType(Number.class)) {
                                addParameterToFunction(variable);
                        }
                        else {
                                {if (true) throw new ParseException(
                                        getFalseTypeExceptionMessage("Short, Integer Long, "
                                        + "SinglePrecisionFloat or DoublePrecisionFloat",
                                        variable.getTypeClass().getSimpleName(), false));}
                        }
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void floatingPoint() throws ParseException {
        FloatingPoint fp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOAT:
      jj_consume_token(FLOAT);
      jj_consume_token(55);
      fp = getSinglePrecisionFloatValue();
      break;
    case DOUBLE:
      jj_consume_token(DOUBLE);
      jj_consume_token(55);
      fp = getDoublePrecisionFloatValue();
      addParameterToFunction(new GenericParameter<FloatingPoint> (fp));
      break;
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void integer() throws ParseException {
        Number num = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SHORT:
      jj_consume_token(SHORT);
      jj_consume_token(55);
      num = getShortValue();
      break;
    case INTEGER:
      jj_consume_token(INTEGER);
      jj_consume_token(55);
      num = getIntegerValue();
      break;
    case LONG:
      jj_consume_token(LONG);
      jj_consume_token(55);
      num = getLongValue();
      break;
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    addParameterToFunction(new GenericParameter<Number> (num));
  }

  final public void interval() throws ParseException {
        GenericParameter <?> variable = null;
        Interval<?> interval = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTERVAL:
      interval = getIntervalParameter();
      addParameterToFunction(new GenericParameter<Interval<?>> (interval));
      break;
    case VARIABLE_NAME:
      variable = getVariableValue();
                if (variable.hasType(Interval.class)) {
                        addParameterToFunction(variable);
                }
                else {
                        {if (true) throw new ParseException(
                                getFalseTypeExceptionMessage(Interval.class.getName(),
                                variable.getTypeClass().getSimpleName(), false));}
                }
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void addParameterToFunction(GenericParameter<?> param) throws ParseException {
    if (this.currentOperationInputMode_)
    {
      currentOperation_.addInputParameter(param);
    }
    else
    {
      currentOperation_.addOutputParameter(param);
    }
  }

/* -----------------Handle interval-type-------------------- */
  final public Interval<?> getIntervalParameter() throws ParseException {
        Interval<FloatingPoint> intervalFloat = new Interval<FloatingPoint>(FloatingPoint.class);
        Interval<Number> intervalInteger = new Interval<Number>(Number.class);

        FloatingPoint floatValue = null;
        Number integerValue = null;
    jj_consume_token(INTERVAL);
    jj_consume_token(56);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOAT:
      jj_consume_token(FLOAT);
      jj_consume_token(57);
      jj_consume_token(58);
                  intervalFloat.specifySubclass(SinglePrecisionFloat.class);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARIABLE_NAME:
      case DIGITS_INTEGER:
      case DIGITS_FLOAT:
      case BIN_32:
      case HEX_8:
      case NEGATIVE_INFINITY:
      case POSITIVE_INFINITY:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DIGITS_INTEGER:
        case DIGITS_FLOAT:
        case BIN_32:
        case HEX_8:
          floatValue = getSinglePrecisionFloatValue();
                                  intervalFloat.setLower_limit(floatValue);
          break;
        case VARIABLE_NAME:
        case NEGATIVE_INFINITY:
        case POSITIVE_INFINITY:
          handleEndpointsAndVariablesForFloat(intervalFloat, true);
          break;
        default:
          jj_la1[17] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(44);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DIGITS_INTEGER:
        case DIGITS_FLOAT:
        case BIN_32:
        case HEX_8:
          floatValue = getSinglePrecisionFloatValue();
                                 intervalFloat.setUpper_limit(floatValue);
          break;
        case VARIABLE_NAME:
        case NEGATIVE_INFINITY:
        case POSITIVE_INFINITY:
          handleEndpointsAndVariablesForFloat(intervalFloat, false);
          break;
        default:
          jj_la1[18] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case EMPTY_SET:
        jj_consume_token(EMPTY_SET);
                          intervalFloat.emptyInterval();
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(59);
                  {if (true) return intervalFloat;}
      break;
    case DOUBLE:
      jj_consume_token(DOUBLE);
      jj_consume_token(57);
      jj_consume_token(58);
                  intervalFloat.specifySubclass(DoublePrecisionFloat.class);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARIABLE_NAME:
      case DIGITS_INTEGER:
      case DIGITS_FLOAT:
      case BIN_64:
      case HEX_16:
      case NEGATIVE_INFINITY:
      case POSITIVE_INFINITY:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DIGITS_INTEGER:
        case DIGITS_FLOAT:
        case BIN_64:
        case HEX_16:
          floatValue = getDoublePrecisionFloatValue();
                                  intervalFloat.setLower_limit(floatValue);
          break;
        case VARIABLE_NAME:
        case NEGATIVE_INFINITY:
        case POSITIVE_INFINITY:
          handleEndpointsAndVariablesForFloat(intervalFloat, true);
          break;
        default:
          jj_la1[20] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(44);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DIGITS_INTEGER:
        case DIGITS_FLOAT:
        case BIN_64:
        case HEX_16:
          floatValue = getDoublePrecisionFloatValue();
                                 intervalFloat.setUpper_limit(floatValue);
          break;
        case VARIABLE_NAME:
        case NEGATIVE_INFINITY:
        case POSITIVE_INFINITY:
          handleEndpointsAndVariablesForFloat(intervalFloat, false);
          break;
        default:
          jj_la1[21] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case EMPTY_SET:
        jj_consume_token(EMPTY_SET);
                          intervalFloat.emptyInterval();
        break;
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(59);
                  {if (true) return intervalFloat;}
      break;
    case SHORT:
      jj_consume_token(SHORT);
      jj_consume_token(57);
      jj_consume_token(58);
                  intervalInteger.specifySubclass(Short.class);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARIABLE_NAME:
      case DIGITS_INTEGER:
      case NEGATIVE_INFINITY:
      case POSITIVE_INFINITY:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DIGITS_INTEGER:
          integerValue = getShortValue();
                                  intervalInteger.setLower_limit(integerValue);
          break;
        case VARIABLE_NAME:
        case NEGATIVE_INFINITY:
        case POSITIVE_INFINITY:
          handleEndpointsAndVariablesForInteger(intervalInteger, true);
          break;
        default:
          jj_la1[23] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(44);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DIGITS_INTEGER:
          integerValue = getShortValue();
                                 intervalInteger.setUpper_limit(integerValue);
          break;
        case VARIABLE_NAME:
        case NEGATIVE_INFINITY:
        case POSITIVE_INFINITY:
          handleEndpointsAndVariablesForInteger(intervalInteger, false);
          break;
        default:
          jj_la1[24] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case EMPTY_SET:
        jj_consume_token(EMPTY_SET);
                          intervalFloat.emptyInterval();
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(59);
                  {if (true) return intervalInteger;}
      break;
    case INTEGER:
      jj_consume_token(INTEGER);
      jj_consume_token(57);
      jj_consume_token(58);
                  intervalInteger.specifySubclass(Integer.class);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARIABLE_NAME:
      case DIGITS_INTEGER:
      case NEGATIVE_INFINITY:
      case POSITIVE_INFINITY:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DIGITS_INTEGER:
          integerValue = getIntegerValue();
                                  intervalInteger.setLower_limit(integerValue);
          break;
        case VARIABLE_NAME:
        case NEGATIVE_INFINITY:
        case POSITIVE_INFINITY:
          handleEndpointsAndVariablesForInteger(intervalInteger, true);
          break;
        default:
          jj_la1[26] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(44);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DIGITS_INTEGER:
          integerValue = getIntegerValue();
                                 intervalInteger.setUpper_limit(integerValue);
          break;
        case VARIABLE_NAME:
        case NEGATIVE_INFINITY:
        case POSITIVE_INFINITY:
          handleEndpointsAndVariablesForInteger(intervalInteger, false);
          break;
        default:
          jj_la1[27] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case EMPTY_SET:
        jj_consume_token(EMPTY_SET);
                          intervalFloat.emptyInterval();
        break;
      default:
        jj_la1[28] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(59);
                  {if (true) return intervalInteger;}
      break;
    case LONG:
      jj_consume_token(LONG);
      jj_consume_token(57);
      jj_consume_token(58);
                  intervalInteger.specifySubclass(Long.class);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARIABLE_NAME:
      case DIGITS_INTEGER:
      case NEGATIVE_INFINITY:
      case POSITIVE_INFINITY:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DIGITS_INTEGER:
          integerValue = getLongValue();
                                  intervalInteger.setLower_limit(integerValue);
          break;
        case VARIABLE_NAME:
        case NEGATIVE_INFINITY:
        case POSITIVE_INFINITY:
          handleEndpointsAndVariablesForInteger(intervalInteger, true);
          break;
        default:
          jj_la1[29] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(44);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DIGITS_INTEGER:
          integerValue = getLongValue();
                                 intervalInteger.setUpper_limit(integerValue);
          break;
        case VARIABLE_NAME:
        case NEGATIVE_INFINITY:
        case POSITIVE_INFINITY:
          handleEndpointsAndVariablesForInteger(intervalInteger, false);
          break;
        default:
          jj_la1[30] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case EMPTY_SET:
        jj_consume_token(EMPTY_SET);
                          intervalFloat.emptyInterval();
        break;
      default:
        jj_la1[31] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(59);
                  {if (true) return intervalInteger;}
      break;
    default:
      jj_la1[32] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void handleEndpointsAndVariablesForFloat(Interval<FloatingPoint> interval, boolean lower) throws ParseException {
        GenericParameter <?> variable = null;
        Endpoints EndpointsValue = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VARIABLE_NAME:
      variable = getVariableValue();
                Class<?> intervalClass = interval.getTypeClass();
                if (variable.hasType(intervalClass)) {
                        if (lower) {
                                interval.setLower_limit((FloatingPoint) variable.getValue());
                        } else {
                                interval.setUpper_limit((FloatingPoint) variable.getValue());
                        }
                }
                else if (variable.hasType(Endpoints.class)) {
                        EndpointsValue = (Endpoints) variable.getValue();
                }
                else {
                        {if (true) throw new ParseException(
                                getFalseTypeExceptionMessage(intervalClass.getName(),
                                variable.getTypeClass().getSimpleName(), true));}
                }
      break;
    case NEGATIVE_INFINITY:
    case POSITIVE_INFINITY:
      EndpointsValue = getInfinityValue();
      break;
    default:
      jj_la1[33] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                if (EndpointsValue != null) {
                        if (lower) {
                                interval.setLowerEndpoint(EndpointsValue);
                        } else {
                                interval.setUpperEndpoint(EndpointsValue);
                        }
                }
  }

  final public void handleEndpointsAndVariablesForInteger(Interval<Number> interval, boolean lower) throws ParseException {
        GenericParameter <?> variable = null;
        Endpoints EndpointsValue = null, emptySet = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VARIABLE_NAME:
      variable = getVariableValue();
                Class<?> intervalClass = interval.getTypeClass();
                if (variable.hasType(intervalClass)) {
                        if (lower) {
                                interval.setLower_limit((Number) variable.getValue());
                        } else {
                                interval.setUpper_limit((Number) variable.getValue());
                        }
                }
                else if (variable.hasType(Endpoints.class)) {
                        EndpointsValue = (Endpoints) variable.getValue();
                }
                else {
                        {if (true) throw new ParseException(
                                getFalseTypeExceptionMessage(intervalClass.getName(),
                                variable.getTypeClass().getSimpleName(), true));}
                }
      break;
    case NEGATIVE_INFINITY:
    case POSITIVE_INFINITY:
      EndpointsValue = getInfinityValue();
      break;
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                if (EndpointsValue != null) {
                        if (lower) {
                                interval.setLowerEndpoint(EndpointsValue);
                        } else {
                                interval.setUpperEndpoint(EndpointsValue);
                        }
                }
  }

  /** Generated Token Manager. */
  public DSLParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[35];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x40040,0x40040,0x0,0x1e00,0x1e00,0x1e00,0x40000000,0xc1b80000,0x0,0x80000000,0x2a400000,0x16400000,0x80040000,0x1bc0000,0x1800000,0x380000,0x40000,0x16440000,0x16440000,0x16440000,0x2a440000,0x2a440000,0x2a440000,0x440000,0x440000,0x440000,0x440000,0x440000,0x440000,0x440000,0x440000,0x440000,0x1b80000,0x40000,0x40000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x7fec40,0x7fec40,0x7fec40,0x0,0x0,0x0,0x0,0xf,0xc,0x1,0x0,0x0,0x1,0x0,0x0,0x0,0x2,0xc,0xc,0x1c,0xc,0xc,0x1c,0xc,0xc,0x1c,0xc,0xc,0x1c,0xc,0xc,0x1c,0x0,0xc,0xc,};
   }

  /** Constructor with InputStream. */
  public DSLParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public DSLParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new DSLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public DSLParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new DSLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public DSLParser(DSLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(DSLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 35; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[60];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 35; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 60; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
